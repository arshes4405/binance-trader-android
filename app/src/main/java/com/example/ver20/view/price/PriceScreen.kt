package com.example.ver20.view.price

import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.platform.LocalContext
import android.widget.Toast
import android.util.Log
import com.example.ver20.dao.mongoDB.UserService
import com.example.ver20.dao.mongoDB.UserData
import com.example.ver20.dao.mongoDB.MongoDbService
import kotlinx.coroutines.launch
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.OkHttpClient
import okhttp3.Request
import kotlin.math.abs
import com.example.ver20.dao.trading.indicator.TechnicalIndicatorCalculator
import com.example.ver20.dao.trading.indicator.IndicatorResult
import java.text.DecimalFormat

// ===== Îç∞Ïù¥ÌÑ∞ Î™®Îç∏ =====

data class TechnicalIndicatorData(
    val timestamp: Long,
    val cciValue: Double,
    val rsiValue: Double
)

// CoinIndicatorInfo Îç∞Ïù¥ÌÑ∞ ÌÅ¥ÎûòÏä§Ïóê ÌòÑÏû¨Í∞Ä/ÏÉÅÏäπÎ•† Ï∂îÍ∞Ä
data class CoinIndicatorInfo(
    val symbol: String,
    val displayName: String,
    val currentPrice: Double = 0.0,        // ÌòÑÏû¨Í∞Ä Ï∂îÍ∞Ä
    val changePercent: Double = 0.0,       // 24ÏãúÍ∞Ñ Î≥ÄÎèôÎ•† Ï∂îÍ∞Ä
    val min15: TechnicalIndicatorData?,
    val hour1: TechnicalIndicatorData?,
    val hour4: TechnicalIndicatorData?,
    val day1: TechnicalIndicatorData?,
    val isLoading: Boolean = false
)

// ===== Î©îÏù∏ ÌôîÎ©¥ - HOMEÏ≤òÎüº Í≤ÄÏùÄÏÉâ Î∞∞Í≤Ω Ï†ÅÏö© =====

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PriceScreen(
    modifier: Modifier = Modifier,
    onShowCreateAccount: () -> Unit = {}
) {
    val context = LocalContext.current
    var coinIndicators by remember { mutableStateOf(getInitialCoinList()) }
    var isRefreshing by remember { mutableStateOf(false) }
    var hasUserInfo by remember { mutableStateOf(false) }
    var currentUser by remember { mutableStateOf<UserData?>(null) }
    var showAddCoinDialog by remember { mutableStateOf(false) }
    val scope = rememberCoroutineScope()

    // HOMEÍ≥º Í∞ôÏùÄ Î∞∞Í≤Ω Í∑∏ÎùºÎç∞Ïù¥ÏÖò
    val gradientBrush = Brush.verticalGradient(
        colors = listOf(
            Color(0xFF0D1117),
            Color(0xFF1A1A2E),
            Color(0xFF16213E)
        )
    )

    // Î™®Îì† ÏΩîÏù∏Ïùò ÏßÄÌëú Î°úÎìú Ìï®Ïàò (Î®ºÏ†Ä Ï†ïÏùò)
    fun loadAllIndicators() {
        scope.launch {
            coinIndicators.forEach { coin ->
                loadIndicatorsForCoin(coin.symbol) { updatedCoin ->
                    scope.launch(Dispatchers.Main) {
                        coinIndicators = coinIndicators.map {
                            if (it.symbol == updatedCoin.symbol) updatedCoin else it
                        }
                    }
                }
            }
        }
    }

    // Ï¶êÍ≤®Ï∞æÍ∏∞ ÏΩîÏù∏ ÏÉàÎ°úÍ≥†Ïπ® Ìï®Ïàò
    fun refreshFavoriteCoins() {
        currentUser?.let { userData ->
            val mongoService = MongoDbService()
            mongoService.getFavoriteCoins(userData.username) { symbols: List<String>, error: String? ->
                scope.launch(Dispatchers.Main) {
                    if (error == null && symbols.isNotEmpty()) {
                        val newCoinList = symbols.map { symbol ->
                            CoinIndicatorInfo(
                                symbol = symbol,
                                displayName = formatDisplayName(symbol),
                                min15 = null,
                                hour1 = null,
                                hour4 = null,
                                day1 = null,
                                isLoading = true
                            )
                        }
                        coinIndicators = newCoinList
                        loadAllIndicators()
                    } else {
                        coinIndicators = emptyList()
                    }
                }
            }
        }
    }

    // ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ Î°úÎìú
    LaunchedEffect(Unit) {
        val userService = UserService()
        val userData = userService.getUserFromPreferences(context)
        currentUser = userData
        hasUserInfo = userData != null

        if (userData != null) {
            refreshFavoriteCoins()
        }
    }

    // ÏΩîÏù∏ Ï∂îÍ∞Ä Îã§Ïù¥ÏñºÎ°úÍ∑∏
    if (showAddCoinDialog) {
        AddCoinDialog(
            onDismiss = { showAddCoinDialog = false },
            onConfirm = { symbol ->
                currentUser?.let { userData ->
                    val mongoService = MongoDbService()
                    mongoService.saveFavoriteCoin(userData.username, symbol.uppercase()) { success: Boolean, message: String? ->
                        scope.launch(Dispatchers.Main) {
                            if (success) {
                                Toast.makeText(context, "ÏΩîÏù∏Ïù¥ Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§", Toast.LENGTH_SHORT).show()
                                refreshFavoriteCoins()
                            } else {
                                Toast.makeText(context, message ?: "Ï∂îÍ∞Ä Ïã§Ìå®", Toast.LENGTH_SHORT).show()
                            }
                            showAddCoinDialog = false
                        }
                    }
                }
            }
        )
    }

    // Î©îÏù∏ UI - Í≤ÄÏùÄÏÉâ Î∞∞Í≤Ω Ï†ÅÏö©
    LazyColumn(
        modifier = modifier
            .fillMaxSize()
            .background(gradientBrush),
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        // ===== Ìó§Îçî Ïπ¥Îìú - Ïñ¥ÎëêÏö¥ ÌÖåÎßàÎ°ú Î≥ÄÍ≤Ω =====
        item {
            Card(
                modifier = Modifier.fillMaxWidth(),
                colors = CardDefaults.cardColors(
                    containerColor = Color.Black.copy(alpha = 0.6f)
                ),
                shape = RoundedCornerShape(16.dp)
            ) {
                Column(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(20.dp)
                ) {
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column {
                            Text(
                                "üìä ÏΩîÏù∏ Í≤ÄÏÉâ",
                                fontSize = 20.sp,
                                fontWeight = FontWeight.Bold,
                                color = Color(0xFFFFD700) // Í≥®ÎìúÏÉâ
                            )
                            if (hasUserInfo && currentUser != null) {
                                Text(
                                    "ÌôòÏòÅÌï©ÎãàÎã§, ${currentUser!!.username}Îãò",
                                    fontSize = 12.sp,
                                    color = Color(0xFFC0C0C0)  // Ïã§Î≤ÑÏÉâÏúºÎ°ú Î≥ÄÍ≤Ω
                                )
                            }
                        }

                        // Î≤ÑÌäº ÏòÅÏó≠
                        if (!hasUserInfo) {
                            Button(
                                onClick = onShowCreateAccount,
                                colors = ButtonDefaults.buttonColors(
                                    containerColor = Color(0xFFFFD700)
                                )
                            ) {
                                Text(
                                    "Í≥ÑÏ†ïÏÉùÏÑ±",
                                    color = Color.Black,
                                    fontSize = 12.sp,
                                    fontWeight = FontWeight.Bold
                                )
                            }
                        } else {
                            Column(
                                horizontalAlignment = Alignment.End,
                                verticalArrangement = Arrangement.spacedBy(6.dp)
                            ) {
                                // ÏΩîÏù∏ Ï∂îÍ∞Ä Î≤ÑÌäº
                                Button(
                                    onClick = { showAddCoinDialog = true },
                                    colors = ButtonDefaults.buttonColors(
                                        containerColor = Color(0xFFFFD700)
                                    ),
                                    modifier = Modifier.height(36.dp)
                                ) {
                                    Icon(
                                        Icons.Default.Add,
                                        contentDescription = "ÏΩîÏù∏ Ï∂îÍ∞Ä",
                                        tint = Color.Black,
                                        modifier = Modifier.size(14.dp)
                                    )
                                    Spacer(modifier = Modifier.width(4.dp))
                                    Text(
                                        "ÏΩîÏù∏Ï∂îÍ∞Ä",
                                        color = Color.Black,
                                        fontSize = 11.sp,
                                        fontWeight = FontWeight.Bold
                                    )
                                }

                                // ÏÉàÎ°úÍ≥†Ïπ® Î≤ÑÌäº
                                Button(
                                    onClick = {
                                        isRefreshing = true
                                        refreshFavoriteCoins()
                                        scope.launch {
                                            kotlinx.coroutines.delay(1000)
                                            isRefreshing = false
                                        }
                                    },
                                    colors = ButtonDefaults.buttonColors(
                                        containerColor = Color(0xFFC0C0C0)  // Ïã§Î≤ÑÏÉâÏúºÎ°ú Î≥ÄÍ≤Ω
                                    ),
                                    modifier = Modifier.height(36.dp)
                                ) {
                                    Icon(
                                        Icons.Default.Refresh,
                                        contentDescription = "ÏÉàÎ°úÍ≥†Ïπ®",
                                        tint = Color.Black,
                                        modifier = Modifier.size(14.dp)
                                    )
                                    Spacer(modifier = Modifier.width(4.dp))
                                    Text(
                                        if (isRefreshing) "ÏóÖÎç∞Ïù¥Ìä∏Ï§ë" else "ÏÉàÎ°úÍ≥†Ïπ®",
                                        color = Color.Black,
                                        fontSize = 11.sp,
                                        fontWeight = FontWeight.Bold
                                    )
                                }
                            }
                        }
                    }
                }
            }
        }

        // ===== ÏΩîÏù∏ Î™©Î°ù ÎòêÎäî ÏïàÎÇ¥ Î©îÏãúÏßÄ - Ïñ¥ÎëêÏö¥ ÌÖåÎßàÎ°ú Î≥ÄÍ≤Ω =====
        if (coinIndicators.isEmpty()) {
            item {
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(
                        containerColor = Color.Black.copy(alpha = 0.4f)
                    ),
                    shape = RoundedCornerShape(16.dp)
                ) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(24.dp),
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        Icon(
                            if (hasUserInfo) Icons.Default.Add else Icons.Default.AccountCircle,
                            contentDescription = null,
                            modifier = Modifier.size(48.dp),
                            tint = Color(0xFFFFD700)
                        )
                        Spacer(modifier = Modifier.height(16.dp))
                        Text(
                            text = if (hasUserInfo) {
                                "Ï¶êÍ≤®Ï∞æÍ∏∞ ÏΩîÏù∏Ïù¥ ÏóÜÏäµÎãàÎã§."
                            } else {
                                "Î°úÍ∑∏Ïù∏ ÌõÑ Ï¶êÍ≤®Ï∞æÍ∏∞ ÏΩîÏù∏ÏùÑ Îì±Î°ùÌïòÏÑ∏Ïöî."
                            },
                            fontSize = 16.sp,
                            fontWeight = FontWeight.Medium,
                            textAlign = TextAlign.Center,
                            color = Color.White
                        )
                        Spacer(modifier = Modifier.height(8.dp))
                        Text(
                            text = if (hasUserInfo) {
                                "'ÏΩîÏù∏Ï∂îÍ∞Ä' Î≤ÑÌäºÏùÑ ÎàåÎü¨ ÏΩîÏù∏ÏùÑ Ï∂îÍ∞ÄÌï¥Î≥¥ÏÑ∏Ïöî!"
                            } else {
                                "Í≥ÑÏ†ïÏùÑ ÏÉùÏÑ±ÌïòÍ≥† Îã§ÏñëÌïú Í∏∞Îä•ÏùÑ Ïù¥Ïö©Ìï¥Î≥¥ÏÑ∏Ïöî."
                            },
                            fontSize = 12.sp,
                            textAlign = TextAlign.Center,
                            color = Color.Gray
                        )
                    }
                }
            }
        } else {
            // ===== ÏßÄÌëú ÌÖåÏù¥Î∏î Ìó§Îçî - Ïñ¥ÎëêÏö¥ ÌÖåÎßàÎ°ú Î≥ÄÍ≤Ω =====
            item {
                Card(
                    modifier = Modifier.fillMaxWidth(),
                    colors = CardDefaults.cardColors(
                        containerColor = Color.Black.copy(alpha = 0.6f)
                    ),
                    shape = RoundedCornerShape(12.dp)
                ) {
                    Column(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(12.dp)
                    ) {
                        // ÌÉÄÏù¥ÌãÄ
                        Text(
                            "üìà Í∏∞Ïà†Ï†Å ÏßÄÌëú ÌòÑÌô©",
                            fontSize = 16.sp,
                            fontWeight = FontWeight.Bold,
                            color = Color(0xFFFFD700),
                            modifier = Modifier.padding(bottom = 12.dp)
                        )

                        // ÌÖåÏù¥Î∏î Ìó§Îçî
                        Row(
                            modifier = Modifier.fillMaxWidth(),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                "ÏΩîÏù∏",
                                modifier = Modifier.weight(0.8f),
                                fontSize = 12.sp,
                                fontWeight = FontWeight.Bold,
                                color = Color.White
                            )
                            Text(
                                "CCI / RSI",
                                modifier = Modifier.weight(2f),
                                fontSize = 12.sp,
                                fontWeight = FontWeight.Bold,
                                textAlign = TextAlign.Center,
                                color = Color(0xFFFFD700)  // Í≥®ÎìúÏÉâÏúºÎ°ú Î≥ÄÍ≤Ω
                            )
                        }

                        // ÏãúÍ∞ÑÎåÄ Ìó§Îçî
                        Row(
                            modifier = Modifier
                                .fillMaxWidth()
                                .padding(top = 4.dp),
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Spacer(modifier = Modifier.weight(0.6f))
                            Row(modifier = Modifier.weight(2f)) {
                                Text("15m", modifier = Modifier.weight(1f), fontSize = 12.sp, textAlign = TextAlign.Center, color = Color(0xFFFFD700), fontWeight = FontWeight.Medium)
                                Text("1h", modifier = Modifier.weight(1.2f), fontSize = 12.sp, textAlign = TextAlign.Center, color = Color(0xFFFFD700), fontWeight = FontWeight.Medium)
                                Text("4h", modifier = Modifier.weight(1f), fontSize = 12.sp, textAlign = TextAlign.Center, color = Color(0xFFFFD700), fontWeight = FontWeight.Medium)
                                Text("1d", modifier = Modifier.weight(1f), fontSize = 12.sp, textAlign = TextAlign.Center, color = Color(0xFFFFD700), fontWeight = FontWeight.Medium)
                            }
                        }
                    }
                }
            }

            // ===== ÏΩîÏù∏Î≥Ñ ÏßÄÌëú Îç∞Ïù¥ÌÑ∞ - Ïñ¥ÎëêÏö¥ ÌÖåÎßàÎ°ú Î≥ÄÍ≤Ω =====
            items(coinIndicators) { coin ->
                CoinIndicatorRow(
                    coin = coin,
                    onRemoveClick = {
                        currentUser?.let { userData ->
                            val mongoService = MongoDbService()
                            mongoService.removeFavoriteCoin(userData.username, coin.symbol) { success: Boolean, message: String? ->
                                scope.launch(Dispatchers.Main) {
                                    if (success) {
                                        Toast.makeText(context, "ÏΩîÏù∏Ïù¥ Ï†úÍ±∞ÎêòÏóàÏäµÎãàÎã§", Toast.LENGTH_SHORT).show()
                                        refreshFavoriteCoins()
                                    } else {
                                        Toast.makeText(context, message ?: "Ï†úÍ±∞ Ïã§Ìå®", Toast.LENGTH_SHORT).show()
                                    }
                                }
                            }
                        }
                    }
                )
            }
        }
    }
}

// ===== ÏΩîÏù∏ ÏßÄÌëú Ìñâ Ïª¥Ìè¨Ï†ÄÎ∏î - Ïñ¥ÎëêÏö¥ ÌÖåÎßàÎ°ú Î≥ÄÍ≤Ω =====

// ===== ÏΩîÏù∏ ÏßÄÌëú Ìñâ Ïª¥Ìè¨Ï†ÄÎ∏î - Í∞ÄÍ≤©/Î≥ÄÎèôÎ•† Ï∂îÍ∞Ä =====

@Composable
fun CoinIndicatorRow(
    coin: CoinIndicatorInfo,
    onRemoveClick: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = Color.Black.copy(alpha = 0.4f)
        ),
        shape = RoundedCornerShape(8.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(12.dp)
        ) {
            // ÏΩîÏù∏ Ïù¥Î¶Ñ, Í∞ÄÍ≤©, Î≥ÄÎèôÎ•† Î∞è Ï†úÍ±∞ Î≤ÑÌäº
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                // ÏôºÏ™Ω: ÏΩîÏù∏ Ï†ïÎ≥¥
                Column {
                    Text(
                        coin.displayName,
                        fontSize = 14.sp,
                        fontWeight = FontWeight.Bold,
                        color = Color.White
                    )
                    Text(
                        coin.symbol,
                        fontSize = 10.sp,
                        color = Color.Gray
                    )
                }

                // Ï§ëÍ∞Ñ: Í∞ÄÍ≤© Î∞è Î≥ÄÎèôÎ•†
                if (coin.currentPrice > 0) {
                    Row(
                        verticalAlignment = Alignment.CenterVertically,
                        horizontalArrangement = Arrangement.spacedBy(8.dp)
                    ) {
                        Text(
                            text = DecimalFormat("#,##0.##").format(coin.currentPrice),
                            fontSize = 13.sp,
                            fontWeight = FontWeight.Bold,
                            color = Color(0xFF64B5F6), // Ïó∞Ìïú ÌååÎûÄÏÉâ
                            textAlign = TextAlign.End,
                            modifier = Modifier.width(80.dp)
                        )
                        Text(
                            text = "${if (coin.changePercent >= 0) "+" else ""}${DecimalFormat("#0.00").format(coin.changePercent)}%",
                            fontSize = 11.sp,
                            fontWeight = FontWeight.Medium,
                            color = if (coin.changePercent >= 0) Color(0xFF4CAF50) else Color(0xFFF44336),
                            textAlign = TextAlign.End,
                            modifier = Modifier.width(60.dp)
                        )
                    }
                }

                // Ïò§Î•∏Ï™Ω: Ï†úÍ±∞ Î≤ÑÌäº
                IconButton(
                    onClick = onRemoveClick,
                    modifier = Modifier.size(24.dp)
                ) {
                    Icon(
                        Icons.Default.Close,
                        contentDescription = "Ï†úÍ±∞",
                        tint = Color(0xFFE57373),
                        modifier = Modifier.size(16.dp)
                    )
                }
            }

            Spacer(modifier = Modifier.height(8.dp))

            // ÏßÄÌëú ÌÖåÏù¥Î∏î
            if (coin.isLoading) {
                Box(
                    modifier = Modifier.fillMaxWidth(),
                    contentAlignment = Alignment.Center
                ) {
                    CircularProgressIndicator(
                        modifier = Modifier.size(24.dp),
                        color = Color(0xFFFFD700)
                    )
                }
            } else {
                // CCI Ìñâ
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        "CCI",
                        modifier = Modifier.weight(1.2f),
                        fontSize = 12.sp,
                        fontWeight = FontWeight.Bold,
                        color = Color(0xFF81C784)
                    )
                    TableIndicatorCell(coin.min15?.cciValue, true, Modifier.weight(1f))
                    TableIndicatorCell(coin.hour1?.cciValue, true, Modifier.weight(1f))
                    TableIndicatorCell(coin.hour4?.cciValue, true, Modifier.weight(1f))
                    TableIndicatorCell(coin.day1?.cciValue, true, Modifier.weight(1f))
                }

                Spacer(modifier = Modifier.height(4.dp))

                // RSI Ìñâ
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        "RSI",
                        modifier = Modifier.weight(1.2f),
                        fontSize = 12.sp,
                        fontWeight = FontWeight.Bold,
                        color = Color(0xFFFFB74D)
                    )
                    TableIndicatorCell(coin.min15?.rsiValue, false, Modifier.weight(1f))
                    TableIndicatorCell(coin.hour1?.rsiValue, false, Modifier.weight(1f))
                    TableIndicatorCell(coin.hour4?.rsiValue, false, Modifier.weight(1f))
                    TableIndicatorCell(coin.day1?.rsiValue, false, Modifier.weight(1f))
                }
            }
        }
    }
}

// ===== ÏßÄÌëú ÏÖÄ Ïª¥Ìè¨Ï†ÄÎ∏î (Í∏∞Ï°¥Í≥º ÎèôÏùº) =====

@Composable
fun TableIndicatorCell(
    value: Double?,
    isCCI: Boolean,
    modifier: Modifier = Modifier
) {
    val backgroundColor: Color
    val textColor: Color
    val displayValue: String

    if (value == null) {
        backgroundColor = Color(0xFF424242)
        textColor = Color(0xFF999999)
        displayValue = "-"
    } else {
        displayValue = String.format("%.1f", value)

        if (isCCI) {
            // CCI ÏÉâÏÉÅ Î°úÏßÅ
            when {
                value >= 100 -> {
                    backgroundColor = Color(0xFFE57373) // Îπ®Í∞ï (Í≥ºÎß§Ïàò)
                    textColor = Color.White
                }
                value <= -100 -> {
                    backgroundColor = Color(0xFF81C784) // Ï¥àÎ°ù (Í≥ºÎß§ÎèÑ)
                    textColor = Color.White
                }
                else -> {
                    backgroundColor = Color(0xFF616161) // Ïñ¥ÎëêÏö¥ ÌöåÏÉâ (Ï§ëÎ¶Ω)
                    textColor = Color.White
                }
            }
        } else {
            // RSI ÏÉâÏÉÅ Î°úÏßÅ
            when {
                value >= 70 -> {
                    backgroundColor = Color(0xFFE57373) // Îπ®Í∞ï (Í≥ºÎß§Ïàò)
                    textColor = Color.White
                }
                value <= 30 -> {
                    backgroundColor = Color(0xFF81C784) // Ï¥àÎ°ù (Í≥ºÎß§ÎèÑ)
                    textColor = Color.White
                }
                else -> {
                    backgroundColor = Color(0xFF616161) // Ïñ¥ÎëêÏö¥ ÌöåÏÉâ (Ï§ëÎ¶Ω)
                    textColor = Color.White
                }
            }
        }
    }

    Box(
        modifier = modifier
            .background(backgroundColor, RoundedCornerShape(4.dp))
            .padding(vertical = 4.dp, horizontal = 2.dp),
        contentAlignment = Alignment.Center
    ) {
        Text(
            displayValue,
            fontSize = 10.sp,
            color = textColor,
            fontWeight = FontWeight.Bold,
            textAlign = TextAlign.Center
        )
    }
}

// ===== ÏΩîÏù∏ Ï∂îÍ∞Ä Îã§Ïù¥ÏñºÎ°úÍ∑∏ - UX Í∞úÏÑ† Î≤ÑÏ†Ñ =====

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AddCoinDialog(
    onDismiss: () -> Unit,
    onConfirm: (String) -> Unit
) {
    var inputText by remember { mutableStateOf("") }
    var isValidSymbol by remember { mutableStateOf(true) }

    // Ïú†Ìö®Ìïú Ïã¨Î≥ºÏù∏ÏßÄ Ï≤¥ÌÅ¨ÌïòÎäî Ìï®Ïàò (Îçî Ïú†Ïó∞ÌïòÍ≤å)
    fun validateSymbol(input: String): Boolean {
        if (input.isBlank()) return false

        // BTC, ETH Í∞ôÏùÄ ÏßßÏùÄ ÏûÖÎ†•ÎèÑ ÌóàÏö©
        val trimmedInput = input.trim().uppercase()

        // Ïù¥ÎØ∏ USDTÍ∞Ä Î∂ôÏñ¥ÏûàÏúºÎ©¥ Í∑∏ÎåÄÎ°ú, ÏóÜÏúºÎ©¥ Ï∂îÍ∞ÄÌï¥ÏÑú Í≤ÄÏ¶ù
        val symbolToCheck = if (trimmedInput.endsWith("USDT")) {
            trimmedInput
        } else {
            "${trimmedInput}USDT"
        }

        // USDT ÌéòÏñ¥ Ìå®ÌÑ¥ Í≤ÄÏ¶ù
        val pattern = "^[A-Z]{2,10}USDT$".toRegex()
        return pattern.matches(symbolToCheck)
    }

    // ÏûÖÎ†•Í∞íÏùÑ USDT Ïã¨Î≥ºÎ°ú Î≥ÄÌôò
    fun convertToUSDTSymbol(input: String): String {
        val trimmedInput = input.trim().uppercase()
        return if (trimmedInput.endsWith("USDT")) {
            trimmedInput
        } else {
            "${trimmedInput}USDT"
        }
    }

    AlertDialog(
        onDismissRequest = onDismiss,
        containerColor = Color(0xFF1E1E1E),
        title = {
            Text(
                "ÏΩîÏù∏ Ï∂îÍ∞Ä",
                fontSize = 18.sp,
                fontWeight = FontWeight.Bold,
                color = Color.White
            )
        },
        text = {
            Column {
                Text(
                    "ÏΩîÏù∏ Ïã¨Î≥ºÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî\n(Ïòà: BTC, ETH, BTCUSDT)",
                    fontSize = 14.sp,
                    color = Color.Gray
                )
                Spacer(modifier = Modifier.height(12.dp))

                OutlinedTextField(
                    value = inputText,
                    onValueChange = {
                        inputText = it.uppercase()
                        isValidSymbol = validateSymbol(inputText)
                    },
                    label = {
                        Text("ÏΩîÏù∏ Ïã¨Î≥º", color = Color.Gray)
                    },
                    placeholder = {
                        Text("BTC ÎòêÎäî BTCUSDT", color = Color.Gray)
                    },
                    modifier = Modifier.fillMaxWidth(),
                    singleLine = true,
                    isError = !isValidSymbol && inputText.isNotBlank(),
                    colors = OutlinedTextFieldDefaults.colors(
                        focusedBorderColor = Color(0xFFFFD700),
                        unfocusedBorderColor = Color.Gray,
                        focusedTextColor = Color.White,        // ÏûÖÎ†• Í∏ÄÏûê ÏÉâÏÉÅ
                        unfocusedTextColor = Color.White,      // ÏûÖÎ†• Í∏ÄÏûê ÏÉâÏÉÅ
                        cursorColor = Color(0xFFFFD700),
                        focusedLabelColor = Color(0xFFFFD700),
                        unfocusedLabelColor = Color.Gray
                    )
                )

                // Î≥ÄÌôò ÎØ∏Î¶¨Î≥¥Í∏∞
                if (inputText.isNotBlank() && isValidSymbol) {
                    val finalSymbol = convertToUSDTSymbol(inputText)
                    if (finalSymbol != inputText.uppercase()) {
                        Spacer(modifier = Modifier.height(8.dp))
                        Text(
                            "‚Üí $finalSymbol Î°ú Ï∂îÍ∞ÄÎê©ÎãàÎã§",
                            color = Color(0xFFFFD700),
                            fontSize = 12.sp,
                            fontWeight = FontWeight.Medium
                        )
                    }
                }

                if (!isValidSymbol && inputText.isNotBlank()) {
                    Text(
                        "Ïò¨Î∞îÎ•∏ ÌòïÏãùÏù¥ ÏïÑÎãôÎãàÎã§ (Ïòà: BTC, BTCUSDT)",
                        color = Color(0xFFE57373),
                        fontSize = 12.sp,
                        modifier = Modifier.padding(top = 4.dp)
                    )
                }

                // Ïù∏Í∏∞ ÏΩîÏù∏ Îπ†Î•∏ ÏÑ†ÌÉù
                Spacer(modifier = Modifier.height(16.dp))
                Text(
                    "Îπ†Î•∏ ÏÑ†ÌÉù:",
                    color = Color.Gray,
                    fontSize = 12.sp
                )
                Spacer(modifier = Modifier.height(8.dp))

                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    val popularCoins = listOf("BTC", "ETH", "BNB", "SOL")
                    popularCoins.forEach { coin ->
                        Card(
                            modifier = Modifier
                                .clickable {
                                    inputText = coin
                                    isValidSymbol = true
                                },
                            colors = CardDefaults.cardColors(
                                containerColor = if (inputText.uppercase() == coin)
                                    Color(0xFFFFD700) else Color(0xFF2D2D2D)
                            )
                        ) {
                            Text(
                                coin,
                                modifier = Modifier.padding(horizontal = 12.dp, vertical = 6.dp),
                                color = if (inputText.uppercase() == coin)
                                    Color.Black else Color.White,
                                fontSize = 12.sp,
                                fontWeight = FontWeight.Bold
                            )
                        }
                    }
                }
            }
        },
        confirmButton = {
            Button(
                onClick = {
                    if (isValidSymbol && inputText.isNotBlank()) {
                        val finalSymbol = convertToUSDTSymbol(inputText)
                        onConfirm(finalSymbol)
                    }
                },
                enabled = isValidSymbol && inputText.isNotBlank(),
                colors = ButtonDefaults.buttonColors(
                    containerColor = Color(0xFFFFD700),
                    disabledContainerColor = Color.Gray
                )
            ) {
                Text(
                    "Ï∂îÍ∞Ä",
                    color = Color.Black,
                    fontWeight = FontWeight.Bold
                )
            }
        },
        dismissButton = {
            TextButton(
                onClick = onDismiss
            ) {
                Text(
                    "Ï∑®ÏÜå",
                    color = Color.Gray
                )
            }
        }
    )
}

// ===== Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§ =====

// ===== DAO Î†àÏù¥Ïñ¥Î•º ÏÇ¨Ïö©Ìïú ÏßÄÌëú Î°úÎìú =====

// loadIndicatorsForCoin Ìï®Ïàò ÏàòÏ†ï - Í∞ÄÍ≤© Ï†ïÎ≥¥ÎèÑ Ìï®Íªò Î°úÎìú
suspend fun loadIndicatorsForCoin(
    symbol: String,
    onResult: (CoinIndicatorInfo) -> Unit
) {
    withContext(Dispatchers.IO) {
        try {
            val indicatorCalculator = TechnicalIndicatorCalculator()

            // 1. Í∏∞Ïà†Ï†Å ÏßÄÌëú Í≥ÑÏÇ∞
            val indicators = indicatorCalculator.calculateMultiTimeframeIndicators(
                symbol = symbol,
                timeframes = listOf("15m", "1h", "4h", "1d"),
                cciPeriod = 20,
                rsiPeriod = 7
            )

            // 2. ÌòÑÏû¨Í∞ÄÏôÄ 24ÏãúÍ∞Ñ Î≥ÄÎèôÎ•† Í∞ÄÏ†∏Ïò§Í∏∞
            val priceInfo = getCurrentPriceAndChange(symbol)

            // IndicatorResultÎ•º TechnicalIndicatorDataÎ°ú Î≥ÄÌôò
            val convertedIndicators = mutableMapOf<String, TechnicalIndicatorData>()
            indicators.forEach { (timeframe, result) ->
                convertedIndicators[timeframe] = TechnicalIndicatorData(
                    timestamp = result.timestamp,
                    cciValue = result.cci,
                    rsiValue = result.rsi
                )
            }

            val updatedCoin = CoinIndicatorInfo(
                symbol = symbol,
                displayName = formatDisplayName(symbol),
                currentPrice = priceInfo.first,      // ÌòÑÏû¨Í∞Ä
                changePercent = priceInfo.second,    // 24ÏãúÍ∞Ñ Î≥ÄÎèôÎ•†
                min15 = convertedIndicators["15m"],
                hour1 = convertedIndicators["1h"],
                hour4 = convertedIndicators["4h"],
                day1 = convertedIndicators["1d"],
                isLoading = false
            )

            Log.d("PriceScreen", "Í∞ÄÍ≤© Ï†ïÎ≥¥ Î°úÎìú ÏôÑÎ£å: $symbol - ÌòÑÏû¨Í∞Ä: ${priceInfo.first}, Î≥ÄÎèôÎ•†: ${priceInfo.second}%")
            onResult(updatedCoin)

        } catch (e: Exception) {
            Log.e("PriceScreen", "Îç∞Ïù¥ÌÑ∞ Î°úÎìú Ïã§Ìå®: ${e.message}")
            val errorCoin = CoinIndicatorInfo(
                symbol = symbol,
                displayName = formatDisplayName(symbol),
                currentPrice = 0.0,
                changePercent = 0.0,
                min15 = null,
                hour1 = null,
                hour4 = null,
                day1 = null,
                isLoading = false
            )
            onResult(errorCoin)
        }
    }
}

// ÌòÑÏû¨Í∞ÄÏôÄ 24ÏãúÍ∞Ñ Î≥ÄÎèôÎ•†ÏùÑ Í∞ÄÏ†∏Ïò§Îäî Ìï®Ïàò Ï∂îÍ∞Ä
suspend fun getCurrentPriceAndChange(symbol: String): Pair<Double, Double> {
    return withContext(Dispatchers.IO) {
        try {
            val client = OkHttpClient()
            val request = Request.Builder()
                .url("https://api.binance.com/api/v3/ticker/24hr?symbol=$symbol")
                .build()

            val response = client.newCall(request).execute()
            val jsonString = response.body?.string() ?: return@withContext Pair(0.0, 0.0)

            // JSON ÌååÏã± (Í∞ÑÎã®Ìïú Î∞©Ïãù)
            val currentPriceRegex = "\"lastPrice\":\"([^\"]+)\"".toRegex()
            val changePercentRegex = "\"priceChangePercent\":\"([^\"]+)\"".toRegex()

            val currentPriceMatch = currentPriceRegex.find(jsonString)
            val changePercentMatch = changePercentRegex.find(jsonString)

            val currentPrice = currentPriceMatch?.groupValues?.get(1)?.toDoubleOrNull() ?: 0.0
            val changePercent = changePercentMatch?.groupValues?.get(1)?.toDoubleOrNull() ?: 0.0

            Pair(currentPrice, changePercent)

        } catch (e: Exception) {
            Log.e("PriceScreen", "Í∞ÄÍ≤© Ï†ïÎ≥¥ Î°úÎìú Ïã§Ìå®: ${e.message}")
            Pair(0.0, 0.0)
        }
    }
}

// Í∏∞Ï°¥ Í≥ÑÏÇ∞ Ìï®ÏàòÎì§ÏùÄ DAOÎ°ú Ïù¥ÎèôÎêòÏñ¥ Ï†úÍ±∞Îê®

fun formatDisplayName(symbol: String): String {
    return when {
        symbol.startsWith("BTC") -> "ÎπÑÌä∏ÏΩîÏù∏"
        symbol.startsWith("ETH") -> "Ïù¥ÎçîÎ¶¨ÏõÄ"
        symbol.startsWith("BNB") -> "Î∞îÏù¥ÎÇ∏Ïä§ÏΩîÏù∏"
        symbol.startsWith("ADA") -> "ÏóêÏù¥Îã§"
        symbol.startsWith("SOL") -> "ÏÜîÎùºÎÇò"
        symbol.startsWith("XRP") -> "Î¶¨Ìîå"
        symbol.startsWith("DOT") -> "Ìè¥Ïπ¥Îã∑"
        symbol.startsWith("DOGE") -> "ÎèÑÏßÄÏΩîÏù∏"
        symbol.startsWith("AVAX") -> "ÏïÑÎ∞úÎûÄÏ≤¥"
        symbol.startsWith("MATIC") -> "Ìè¥Î¶¨Í≥§"
        else -> symbol.replace("USDT", "")
    }
}

fun getInitialCoinList(): List<CoinIndicatorInfo> {
    return emptyList()
}