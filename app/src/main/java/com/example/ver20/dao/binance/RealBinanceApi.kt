// RealBinanceApi.kt - ÏôÑÏ†ÑÌïú ÏÉà Î≤ÑÏ†Ñ

package com.example.ver20.dao.binance

import android.util.Log
import com.example.ver20.dao.dataclass.AccountInfo
import com.example.ver20.dao.dataclass.AccountResponse
import com.example.ver20.dao.dataclass.ApiKeyData
import com.example.ver20.dao.dataclass.BalanceInfo
import com.example.ver20.dao.dataclass.BalanceUtils
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import retrofit2.Response
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.http.*
import javax.crypto.Mac
import javax.crypto.spec.SecretKeySpec

// ===========================================
// Spot API Ïù∏ÌÑ∞ÌéòÏù¥Ïä§
// ===========================================

interface RealBinanceApi {
    @GET("api/v3/account")
    suspend fun getAccountInfo(
        @Query("timestamp") timestamp: Long,
        @Query("signature") signature: String,
        @Header("X-MBX-APIKEY") apiKey: String
    ): Response<BinanceAccountResponse>

    @GET("api/v3/time")
    suspend fun getServerTime(): Response<ServerTimeResponse>

    @GET("api/v3/ticker/price")
    suspend fun getAllPrices(): Response<List<PriceResponse>>

    @GET("api/v3/ticker/price")
    suspend fun getPrice(@Query("symbol") symbol: String): Response<PriceResponse>
}

// ===========================================
// Futures API Ïù∏ÌÑ∞ÌéòÏù¥Ïä§
// ===========================================

interface BinanceFuturesApi {
    @GET("fapi/v2/account")
    suspend fun getFuturesAccountInfo(
        @Query("timestamp") timestamp: Long,
        @Query("signature") signature: String,
        @Header("X-MBX-APIKEY") apiKey: String
    ): Response<BinanceFuturesAccountResponse>

    @GET("fapi/v1/time")
    suspend fun getFuturesServerTime(): Response<ServerTimeResponse>
}

// ===========================================
// Í∏∞Î≥∏ ÏùëÎãµ Îç∞Ïù¥ÌÑ∞ ÌÅ¥ÎûòÏä§
// ===========================================

data class ServerTimeResponse(
    val serverTime: Long
)


// ===========================================
// Spot API ÏùëÎãµ Îç∞Ïù¥ÌÑ∞ ÌÅ¥ÎûòÏä§
// ===========================================

data class BinanceAccountResponse(
    val makerCommission: Int,
    val takerCommission: Int,
    val buyerCommission: Int,
    val sellerCommission: Int,
    val canTrade: Boolean,
    val canWithdraw: Boolean,
    val canDeposit: Boolean,
    val updateTime: Long,
    val accountType: String,
    val balances: List<BinanceBalance>,
    val permissions: List<String>
)

data class BinanceBalance(
    val asset: String,
    val free: String,
    val locked: String
)

// ===========================================
// Futures API ÏùëÎãµ Îç∞Ïù¥ÌÑ∞ ÌÅ¥ÎûòÏä§
// ===========================================

data class BinanceFuturesAccountResponse(
    val feeTier: Int,
    val canTrade: Boolean,
    val canDeposit: Boolean,
    val canWithdraw: Boolean,
    val updateTime: Long,
    val totalWalletBalance: String,
    val totalUnrealizedProfit: String,
    val totalMarginBalance: String,
    val availableBalance: String,
    val assets: List<BinanceFuturesAsset>,
    val positions: List<BinanceFuturesPosition>
)

data class BinanceFuturesAsset(
    val asset: String,
    val walletBalance: String,
    val unrealizedProfit: String,
    val marginBalance: String,
    val availableBalance: String
)

data class BinanceFuturesPosition(
    val symbol: String,
    val initialMargin: String,
    val maintMargin: String,
    val unrealizedProfit: String,
    val leverage: String,
    val isolated: Boolean,
    val entryPrice: String,
    val positionSide: String,
    val positionAmt: String,
    val updateTime: Long
)

// ===========================================
// ÎÇ¥Î∂Ä Îç∞Ïù¥ÌÑ∞ ÌÅ¥ÎûòÏä§
// ===========================================

data class FuturesAccountInfo(
    val totalWalletBalance: Double,
    val totalUnrealizedProfit: Double,
    val totalMarginBalance: Double,
    val availableBalance: Double,
    val assets: List<FuturesAssetInfo>,
    val positions: List<FuturesPositionInfo>,
    val canTrade: Boolean,
    val canWithdraw: Boolean,
    val canDeposit: Boolean
)

data class FuturesAssetInfo(
    val asset: String,
    val walletBalance: Double,
    val unrealizedProfit: Double,
    val marginBalance: Double,
    val availableBalance: Double
)

data class FuturesPositionInfo(
    val symbol: String,
    val positionAmt: Double,
    val entryPrice: Double,
    val unrealizedProfit: Double,
    val leverage: String,
    val positionSide: String,
    val isolated: Boolean
)

// ===========================================
// ÌÜµÌï© Î∞îÏù¥ÎÇ∏Ïä§ ÏÑúÎπÑÏä§
// ===========================================

class RealBinanceService {
    companion object {
        private const val TAG = "RealBinanceService"
        private const val MAINNET_URL = "https://api.binance.com/"
        private const val TESTNET_URL = "https://testnet.binance.vision/"
        private const val FUTURES_MAINNET_URL = "https://fapi.binance.com/"
        private const val FUTURES_TESTNET_URL = "https://testnet.binancefuture.com/"
    }

    // Spot API Retrofit Ïù∏Ïä§ÌÑ¥Ïä§
    private val mainnetRetrofit = Retrofit.Builder()
        .baseUrl(MAINNET_URL)
        .addConverterFactory(GsonConverterFactory.create())
        .build()

    private val testnetRetrofit = Retrofit.Builder()
        .baseUrl(TESTNET_URL)
        .addConverterFactory(GsonConverterFactory.create())
        .build()

    // Futures API Retrofit Ïù∏Ïä§ÌÑ¥Ïä§
    private val futuresMainnetRetrofit = Retrofit.Builder()
        .baseUrl(FUTURES_MAINNET_URL)
        .addConverterFactory(GsonConverterFactory.create())
        .build()

    private val futuresTestnetRetrofit = Retrofit.Builder()
        .baseUrl(FUTURES_TESTNET_URL)
        .addConverterFactory(GsonConverterFactory.create())
        .build()

    // API Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ± Ìï®ÏàòÎì§
    private fun getSpotApi(isTestnet: Boolean): RealBinanceApi {
        return if (isTestnet) {
            testnetRetrofit.create(RealBinanceApi::class.java)
        } else {
            mainnetRetrofit.create(RealBinanceApi::class.java)
        }
    }

    private fun getFuturesApi(isTestnet: Boolean): BinanceFuturesApi {
        return if (isTestnet) {
            futuresTestnetRetrofit.create(BinanceFuturesApi::class.java)
        } else {
            futuresMainnetRetrofit.create(BinanceFuturesApi::class.java)
        }
    }

    // HMAC SHA256 ÏÑúÎ™Ö ÏÉùÏÑ±
    private fun createSignature(data: String, secretKey: String): String {
        return try {
            val mac = Mac.getInstance("HmacSHA256")
            val secretKeySpec = SecretKeySpec(secretKey.toByteArray(), "HmacSHA256")
            mac.init(secretKeySpec)
            val signature = mac.doFinal(data.toByteArray())
            signature.joinToString("") { "%02x".format(it) }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå ÏÑúÎ™Ö ÏÉùÏÑ± Ïã§Ìå®: ${e.message}")
            ""
        }
    }

    // Spot ÏÑúÎ≤Ñ ÏãúÍ∞Ñ Ï°∞Ìöå
    private suspend fun getSpotServerTime(isTestnet: Boolean): Long? {
        return try {
            val api = getSpotApi(isTestnet)
            val response = api.getServerTime()
            if (response.isSuccessful && response.body() != null) {
                response.body()!!.serverTime
            } else null
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Spot ÏÑúÎ≤Ñ ÏãúÍ∞Ñ Ï°∞Ìöå Ïã§Ìå®: ${e.message}")
            null
        }
    }

    // Futures ÏÑúÎ≤Ñ ÏãúÍ∞Ñ Ï°∞Ìöå
    private suspend fun getFuturesServerTime(isTestnet: Boolean): Long? {
        return try {
            val api = getFuturesApi(isTestnet)
            val response = api.getFuturesServerTime()
            if (response.isSuccessful && response.body() != null) {
                response.body()!!.serverTime
            } else null
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Futures ÏÑúÎ≤Ñ ÏãúÍ∞Ñ Ï°∞Ìöå Ïã§Ìå®: ${e.message}")
            null
        }
    }

    // Spot Í≥ÑÏ¢å Ï†ïÎ≥¥ Ï°∞Ìöå
    suspend fun getAccountInfo(apiKeyData: ApiKeyData): AccountResponse = withContext(Dispatchers.IO) {
        return@withContext try {
            Log.d(TAG, "üîÑ Spot Í≥ÑÏ¢å Ï†ïÎ≥¥ Ï°∞Ìöå ÏãúÏûë")

            val api = getSpotApi(apiKeyData.isTestnet)
            val serverTime = getSpotServerTime(apiKeyData.isTestnet)

            if (serverTime == null) {
                return@withContext AccountResponse(false, null, "Spot ÏÑúÎ≤Ñ ÏãúÍ∞Ñ Ï°∞Ìöå Ïã§Ìå®")
            }

            val timestamp = serverTime
            val queryString = "timestamp=$timestamp"
            val signature = createSignature(queryString, apiKeyData.secretKey)

            if (signature.isEmpty()) {
                return@withContext AccountResponse(false, null, "ÏÑúÎ™Ö ÏÉùÏÑ± Ïã§Ìå®")
            }

            val response = api.getAccountInfo(timestamp, signature, apiKeyData.apiKey)

            if (response.isSuccessful && response.body() != null) {
                val binanceAccount = response.body()!!
                val accountInfo = AccountInfo(
                    makerCommission = binanceAccount.makerCommission,
                    takerCommission = binanceAccount.takerCommission,
                    buyerCommission = binanceAccount.buyerCommission,
                    sellerCommission = binanceAccount.sellerCommission,
                    canTrade = binanceAccount.canTrade,
                    canWithdraw = binanceAccount.canWithdraw,
                    canDeposit = binanceAccount.canDeposit,
                    updateTime = binanceAccount.updateTime,
                    accountType = "SPOT",
                    balances = binanceAccount.balances.map { balance ->
                        BalanceInfo(balance.asset, balance.free, balance.locked)
                    },
                    permissions = binanceAccount.permissions
                )

                Log.d(TAG, "‚úÖ Spot Í≥ÑÏ¢å Ï†ïÎ≥¥ Ï°∞Ìöå ÏÑ±Í≥µ! ÏûêÏÇ∞ Í∞úÏàò: ${accountInfo.balances.size}")
                AccountResponse(true, accountInfo, "Spot Í≥ÑÏ¢å Ï†ïÎ≥¥ Ï°∞Ìöå ÏÑ±Í≥µ")
            } else {
                val errorMessage = when (response.code()) {
                    401 -> "API ÌÇ§ Ïù∏Ï¶ù Ïã§Ìå®"
                    403 -> "API Í∂åÌïú Î∂ÄÏ°± ÎòêÎäî IP Ï†úÌïú"
                    429 -> "API ÏöîÏ≤≠ ÌïúÎèÑ Ï¥àÍ≥º"
                    else -> "API Ìò∏Ï∂ú Ïã§Ìå®: ${response.code()}"
                }
                AccountResponse(false, null, errorMessage)
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Spot Í≥ÑÏ¢å Ï†ïÎ≥¥ Ï°∞Ìöå ÏòàÏô∏: ${e.message}")
            AccountResponse(false, null, "ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò: ${e.message}")
        }
    }

    // Futures Í≥ÑÏ¢å Ï†ïÎ≥¥ Ï°∞Ìöå
    suspend fun getFuturesAccountInfo(apiKeyData: ApiKeyData): Pair<Boolean, FuturesAccountInfo?> = withContext(Dispatchers.IO) {
        return@withContext try {
            Log.d(TAG, "üîÑ Futures Í≥ÑÏ¢å Ï†ïÎ≥¥ Ï°∞Ìöå ÏãúÏûë")

            val api = getFuturesApi(apiKeyData.isTestnet)
            val serverTime = getFuturesServerTime(apiKeyData.isTestnet)

            if (serverTime == null) {
                Log.e(TAG, "‚ùå Futures ÏÑúÎ≤Ñ ÏãúÍ∞Ñ Ï°∞Ìöå Ïã§Ìå®")
                return@withContext Pair(false, null)
            }

            val timestamp = serverTime
            val queryString = "timestamp=$timestamp"
            val signature = createSignature(queryString, apiKeyData.secretKey)

            if (signature.isEmpty()) {
                Log.e(TAG, "‚ùå Futures ÏÑúÎ™Ö ÏÉùÏÑ± Ïã§Ìå®")
                return@withContext Pair(false, null)
            }

            val response = api.getFuturesAccountInfo(timestamp, signature, apiKeyData.apiKey)

            if (response.isSuccessful && response.body() != null) {
                val futuresAccount = response.body()!!

                val futuresInfo = FuturesAccountInfo(
                    totalWalletBalance = futuresAccount.totalWalletBalance.toDoubleOrNull() ?: 0.0,
                    totalUnrealizedProfit = futuresAccount.totalUnrealizedProfit.toDoubleOrNull() ?: 0.0,
                    totalMarginBalance = futuresAccount.totalMarginBalance.toDoubleOrNull() ?: 0.0,
                    availableBalance = futuresAccount.availableBalance.toDoubleOrNull() ?: 0.0,
                    canTrade = futuresAccount.canTrade,
                    canWithdraw = futuresAccount.canWithdraw,
                    canDeposit = futuresAccount.canDeposit,
                    assets = futuresAccount.assets.map { asset ->
                        FuturesAssetInfo(
                            asset = asset.asset,
                            walletBalance = asset.walletBalance.toDoubleOrNull() ?: 0.0,
                            unrealizedProfit = asset.unrealizedProfit.toDoubleOrNull() ?: 0.0,
                            marginBalance = asset.marginBalance.toDoubleOrNull() ?: 0.0,
                            availableBalance = asset.availableBalance.toDoubleOrNull() ?: 0.0
                        )
                    }.filter { it.walletBalance > 0 || it.marginBalance > 0 },
                    positions = futuresAccount.positions.map { position ->
                        FuturesPositionInfo(
                            symbol = position.symbol,
                            positionAmt = position.positionAmt.toDoubleOrNull() ?: 0.0,
                            entryPrice = position.entryPrice.toDoubleOrNull() ?: 0.0,
                            unrealizedProfit = position.unrealizedProfit.toDoubleOrNull() ?: 0.0,
                            leverage = position.leverage,
                            positionSide = position.positionSide,
                            isolated = position.isolated
                        )
                    }.filter { it.positionAmt != 0.0 }
                )

                Log.d(TAG, "‚úÖ Futures Í≥ÑÏ¢å Ï†ïÎ≥¥ Ï°∞Ìöå ÏÑ±Í≥µ!")
                Log.d(TAG, "üí∞ Ï¥ù ÏßÄÍ∞ë ÏûîÍ≥†: ${futuresInfo.totalWalletBalance}")
                Log.d(TAG, "üìä ÏûêÏÇ∞ Í∞úÏàò: ${futuresInfo.assets.size}")
                Log.d(TAG, "üìà Ìè¨ÏßÄÏÖò Í∞úÏàò: ${futuresInfo.positions.size}")

                Pair(true, futuresInfo)
            } else {
                Log.e(TAG, "‚ùå Futures Í≥ÑÏ¢å Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå®: ${response.code()}")
                Pair(false, null)
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Futures Í≥ÑÏ¢å Ï†ïÎ≥¥ Ï°∞Ìöå ÏòàÏô∏: ${e.message}")
            Pair(false, null)
        }
    }

    // Í∞ÄÍ≤© Ï†ïÎ≥¥ Ï°∞Ìöå
    suspend fun getAllPrices(isTestnet: Boolean): Map<String, Double> = withContext(Dispatchers.IO) {
        return@withContext try {
            Log.d(TAG, "üîÑ Í∞ÄÍ≤© Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë...")
            val api = getSpotApi(isTestnet)
            val response = api.getAllPrices()

            if (response.isSuccessful && response.body() != null) {
                val prices = response.body()!!.associate { priceResponse ->
                    priceResponse.symbol to (priceResponse.price.toDoubleOrNull() ?: 0.0)
                }
                Log.d(TAG, "‚úÖ Í∞ÄÍ≤© Ï†ïÎ≥¥ Ï°∞Ìöå ÏÑ±Í≥µ: ${prices.size}Í∞ú")
                prices
            } else {
                Log.e(TAG, "‚ùå Í∞ÄÍ≤© Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå®: ${response.code()}")
                emptyMap()
            }
        } catch (e: Exception) {
            Log.e(TAG, "‚ùå Í∞ÄÍ≤© Ï†ïÎ≥¥ Ï°∞Ìöå ÏòàÏô∏: ${e.message}")
            emptyMap()
        }
    }

    // ÌÜµÌï© Í≥ÑÏ¢å Ï†ïÎ≥¥ Ï°∞Ìöå (Spot + Futures + Í∞ÄÍ≤©Ï†ïÎ≥¥)
    suspend fun getIntegratedAccountInfo(apiKeyData: ApiKeyData): Triple<AccountResponse, FuturesAccountInfo?, Map<String, Double>> {
        Log.d(TAG, "üöÄ ÌÜµÌï© Í≥ÑÏ¢å Ï†ïÎ≥¥ Ï°∞Ìöå ÏãúÏûë")

        val spotResponse = getAccountInfo(apiKeyData)
        val (futuresSuccess, futuresInfo) = getFuturesAccountInfo(apiKeyData)
        val priceMap = getAllPrices(apiKeyData.isTestnet)

        Log.d(TAG, "üìä ÌÜµÌï© Ï°∞Ìöå ÏôÑÎ£å - Spot: ${spotResponse.success}, Futures: $futuresSuccess")

        return Triple(spotResponse, futuresInfo, priceMap)
    }
}

// ===========================================
// Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§
// ===========================================

// Futures ÏûêÏÇ∞ÏùÑ BalanceInfo ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
fun FuturesAssetInfo.toBalanceInfo(): BalanceInfo {
    return BalanceInfo(
        asset = this.asset,
        free = this.availableBalance.toString(),
        locked = (this.walletBalance - this.availableBalance).toString()
    )
}

// ÌÜµÌï© ÏûêÏÇ∞ Î∂ÑÎ•ò Ìï®Ïàò
suspend fun classifyIntegratedAssets(
    spotBalances: List<BalanceInfo>,
    futuresInfo: FuturesAccountInfo?,
    priceMap: Map<String, Double>,
    callback: (List<BalanceInfo>, List<BalanceInfo>, List<BalanceInfo>, Double, Double, Double) -> Unit
) {
    val nonZeroSpotBalances = BalanceUtils.getNonZeroBalances(spotBalances)

    // Futures ÏûêÏÇ∞ÏùÑ BalanceInfo ÌòïÏãùÏúºÎ°ú Î≥ÄÌôò
    val futuresBalances = futuresInfo?.assets?.map { it.toBalanceInfo() } ?: emptyList()
    val nonZeroFuturesBalances = BalanceUtils.getNonZeroBalances(futuresBalances)

    // Spot ÏûêÏÇ∞: Î™®Îì† ÌòÑÎ¨º Í±∞Îûò ÏûêÏÇ∞
    val spotAssets = nonZeroSpotBalances

    // Earn ÏûêÏÇ∞: Ïä§ÌÖåÏù¥ÌÇπ Í∞ÄÎä•Ìïú Ï£ºÏöî ÏïîÌò∏ÌôîÌèê (ÏµúÏÜå 10Îã¨Îü¨ Ïù¥ÏÉÅ)
    val earnCandidates = listOf("BNB", "ETH", "ADA", "DOT", "SOL", "MATIC", "AVAX", "ATOM")
    val earnAssets = nonZeroSpotBalances.filter { balance ->
        if (balance.asset in earnCandidates) {
            val totalAmount = BalanceUtils.getTotalBalance(balance)
            val usdValue = calculateSimpleUSDValue(balance.asset, totalAmount, priceMap)
            usdValue >= 10.0
        } else false
    }

    // Futures ÏûêÏÇ∞: Ïã§Ï†ú ÏÑ†Î¨º Í≥ÑÏ¢åÏùò ÏûêÏÇ∞Îì§
    val futuresAssets = nonZeroFuturesBalances

    // Í∞Å ÌÉ≠Î≥Ñ Ïã§Ï†ú USD Ï¥ùÏï° Í≥ÑÏÇ∞
    val spotTotalUSD = calculateTotalUSDValue(spotAssets, priceMap)
    val earnTotalUSD = calculateTotalUSDValue(earnAssets, priceMap)
    val futuresTotalUSD = calculateTotalUSDValue(futuresAssets, priceMap)

    Log.d("AssetClassify", "üí∞ ÏûêÏÇ∞ Î∂ÑÎ•ò ÏôÑÎ£å - Spot: $${spotTotalUSD}, Earn: $${earnTotalUSD}, Futures: $${futuresTotalUSD}")

    callback(spotAssets, earnAssets, futuresAssets, spotTotalUSD, earnTotalUSD, futuresTotalUSD)
}

// Í∞ÑÎã®Ìïú USD Í∞ÄÏπò Í≥ÑÏÇ∞
suspend fun calculateSimpleUSDValue(asset: String, amount: Double, priceMap: Map<String, Double>): Double {
    return when (asset) {
        "USDT", "BUSD", "USDC", "FDUSD" -> amount
        else -> {
            val usdtPair = "${asset}USDT"
            val price = priceMap[usdtPair] ?: 0.0
            amount * price
        }
    }
}

// Ï¥ù USD Í∞ÄÏπò Í≥ÑÏÇ∞
suspend fun calculateTotalUSDValue(balances: List<BalanceInfo>, priceMap: Map<String, Double>): Double {
    return balances.sumOf { balance ->
        val totalAmount = BalanceUtils.getTotalBalance(balance)
        calculateSimpleUSDValue(balance.asset, totalAmount, priceMap)
    }
}